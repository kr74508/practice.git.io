const 변수
-변수에 const를 사용해 상수의 의미를 갖게하고 내용을 변경할 수 없게 함
-반드시 초기값이 필요함

함수 const
-함수 선언시 함수, 매개변수, 리턴형에 선언
-읽기 전용

void func(const int); 매개변수
const double func(int); 리턴값
void func(void) const; 멤버변수 변경x

const 멤버
-멤버변수를 변경하는 치환연산
-지정된 함수에서는 멤버변수의 값을 변경 불가

const 객체
-객체가 const로 지정되면 초기화된 데이터는 변경x
-객체를 const로 지정하려면 객체 정의시 클래스명 앞에 const추가

포인터
-주소를 저장하는 변수
-메모리의 주소를 이용해 메모리의 내용을 직접 접근
-call by reference로 함수로부터 한 개 이상의 값을 리턴할 때 사용

포인터와 주소
-메모리 구분 숫자 => 메모리의 주소, 번지, address
-메모리의 주소를 저장하려면 일반 변수가 아닌 포인터를 사용

포인터 선언
-사용하기 전에 선언
-자료형과 변수명 사이에 구두점 *을 더 쓰면 됨

참조 연산자 *
-포인터에 주소를 대입하는 방법
-일반적으로 일반 변수명 앞에 &를 사용해 변수의 주소를 저장

* 선언문 ( 구두점
-포인터를 선언할 때

* 실행문 ( 연산자
-주소로 가서 값을 가져올 때
-저장된 주소로 가서 실제 데이터 값을 가져오는데 사용

포인터의 자료형과 대입
-int는 pi가 int형 데이터 참조 포인터라는 의미

포인터 초기화
-자료형 *포인터_변수명=초기화 주소;

s[i]==*(s+i)
-배열의 이름은 그 배열의 시작주소를 저장하는 포인터
-배열의 이름 s는 첫 번째 원소의 주소(&s[0])를 저장하는
포인터이므로 그 곳의 내용을 참조(*s)하면 그 값이 s[0]

s[0] *(s+0) *(0+s)
S[1] *(s+1) *(1+s)
S[2] *(s+2) *(2+s)
s[3] *(s+3) *(3+s)
s[4] *(s+4) *(4+s)

지역변수와 전역변수
-프로그램 내 변수가 사용될 수 있는 범위
-지역 변수는 해당 함수나 블록({ }) 내에서만 사용
-전역 변수는 소스 전체에서사용
-선언 위치에 따라서 결정

코드 영역과 데이터 영역
-소스와 프로그램에서 사용될 데이터로 구성
-소스는 컴파일과 링킹 과정을 거쳐 기계어로 번역
-기계어로 번역된 코드는 메모리의 코드영역에 저장(읽기만 가능)
-사용할 변수 등의 데이터는 읽기 쓰기가 가능한 데이터 영역에 저장
-지역 변수는 스택 영역을 사용하고 전역 변수는 데이터 영역을 사용

프로그램 메모리 레이아웃
-지역변수, 전역변수, 동적 메모리 할당!

동적 메모리 (heap
.장점
-지역 내에서 프로그램이 끝날 때까지 값을 유지
 ㄴ메모리를 해제(delete) 전까지
- 프로그램을 실행할 때 메모리의 양을 결정
-스택 공간 부족시 스택 오버플로우 오류(heap에 할당해야 함)
-★new : 메모리 할당, 할당된 메모리 시작주소 리턴
.단점
-스택보다 느림
-확보된 기억공간은 기억공간에 이름이 없기 때문에 주소를 사용 포인터 이해가 필요

정적 메모리 (스택)
-컴파일시 필요한 메모리 할당
-kB까지는 스택 사용 그 이상은 heap

동적 메모리 할당과 해제
ㅇ기본 자료형
-할당
포인터 변수 = new 자료형;
포인터 변수 = new 자료형(초기값);
ex)int *pi=net int;
ex)int *pi=net int(1);
-해제
delete 포인터 변수;
ex)delete pi;

ㅇ배열
포인터변수 = new 배열;
ex)int *pi=new int[5];
delete []포인터변수;
ex)delete []pi;

new
-할당된 메모리에 대한 주소 반환
-메모리가 충분하지 않으면 null포인터 반환
-메모리 시작주소를 자동반환

new와 delete는 중첩가능
-동적객체 초기화o (생성자 자동호출)





